{"id": 164, "timestamp": "2025-12-13T15:54:13.975746", "source": "agent", "message": "Command `sed -n '1,240p' /workspace/matplotlib/lib/matplotlib/mathtext.py` executed with exit code 0.", "cause": 163, "observation": "run", "tool_call_metadata": {"function_name": "execute_bash", "tool_call_id": "call_ZRRS7SiHx3NCw2lLXG8TPiKk", "model_response": {"id": "chatcmpl-CmMEdT2QJGFhl7Aqt1ekmVZmRwD1p", "created": 1765641251, "model": "gpt-5-mini-2025-08-07", "object": "chat.completion", "system_fingerprint": null, "choices": [{"finish_reason": "tool_calls", "index": 0, "message": {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"command\":\"sed -n '1,240p' /workspace/matplotlib/lib/matplotlib/mathtext.py\",\"timeout\":120000,\"security_risk\":\"LOW\"}", "name": "execute_bash"}, "id": "call_ZRRS7SiHx3NCw2lLXG8TPiKk", "type": "function"}], "function_call": null, "annotations": []}, "provider_specific_fields": {}}], "usage": {"completion_tokens": 49, "prompt_tokens": 43506, "total_tokens": 43555, "completion_tokens_details": {"accepted_prediction_tokens": 0, "audio_tokens": 0, "reasoning_tokens": 0, "rejected_prediction_tokens": 0, "text_tokens": null}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 43136, "text_tokens": null, "image_tokens": null}}, "service_tier": "default"}, "total_calls_in_response": 1}, "content": "r\"\"\"\nA module for parsing a subset of the TeX math syntax and rendering it to a\nMatplotlib backend.\n\nFor a tutorial of its usage, see :doc:`/tutorials/text/mathtext`.  This\ndocument is primarily concerned with implementation details.\n\nThe module uses pyparsing_ to parse the TeX expression.\n\n.. _pyparsing: https://pypi.org/project/pyparsing/\n\nThe Bakoma distribution of the TeX Computer Modern fonts, and STIX\nfonts are supported.  There is experimental support for using\narbitrary fonts, but results may vary without proper tweaking and\nmetrics for those fonts.\n\"\"\"\n\nfrom collections import namedtuple\nimport functools\nimport logging\n\nimport numpy as np\n\nfrom matplotlib import _api, rcParams, _mathtext\nfrom matplotlib.ft2font import FT2Image, LOAD_NO_HINTING\nfrom matplotlib.font_manager import FontProperties\n\n_log = logging.getLogger(__name__)\n\n\nget_unicode_index = _mathtext.get_unicode_index\nget_unicode_index.__module__ = __name__\n\n\nclass MathtextBackend:\n    \"\"\"\n    The base class for the mathtext backend-specific code.  `MathtextBackend`\n    subclasses interface between mathtext and specific Matplotlib graphics\n    backends.\n\n    Subclasses need to override the following:\n\n    - :meth:`render_glyph`\n    - :meth:`render_rect_filled`\n    - :meth:`get_results`\n\n    And optionally, if you need to use a FreeType hinting style:\n\n    - :meth:`get_hinting_type`\n    \"\"\"\n    def __init__(self):\n        self.width = 0\n        self.height = 0\n        self.depth = 0\n\n    def set_canvas_size(self, w, h, d):\n        \"\"\"Set the dimension of the drawing canvas.\"\"\"\n        self.width  = w\n        self.height = h\n        self.depth  = d\n\n    def render_glyph(self, ox, oy, info):\n        \"\"\"\n        Draw a glyph described by *info* to the reference point (*ox*,\n        *oy*).\n        \"\"\"\n        raise NotImplementedError()\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        \"\"\"\n        Draw a filled black rectangle from (*x1*, *y1*) to (*x2*, *y2*).\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_results(self, box):\n        \"\"\"\n        Return a backend-specific tuple to return to the backend after\n        all processing is done.\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_hinting_type(self):\n        \"\"\"\n        Get the FreeType hinting type to use with this particular\n        backend.\n        \"\"\"\n        return LOAD_NO_HINTING\n\n\nclass MathtextBackendAgg(MathtextBackend):\n    \"\"\"\n    Render glyphs and rectangles to an FTImage buffer, which is later\n    transferred to the Agg image by the Agg backend.\n    \"\"\"\n    def __init__(self):\n        self.ox = 0\n        self.oy = 0\n        self.image = None\n        self.mode = 'bbox'\n        self.bbox = [0, 0, 0, 0]\n        super().__init__()\n\n    def _update_bbox(self, x1, y1, x2, y2):\n        self.bbox = [min(self.bbox[0], x1),\n                     min(self.bbox[1], y1),\n                     max(self.bbox[2], x2),\n                     max(self.bbox[3], y2)]\n\n    def set_canvas_size(self, w, h, d):\n        super().set_canvas_size(w, h, d)\n        if self.mode != 'bbox':\n            self.image = FT2Image(np.ceil(w), np.ceil(h + max(d, 0)))\n\n    def render_glyph(self, ox, oy, info):\n        if self.mode == 'bbox':\n            self._update_bbox(ox + info.metrics.xmin,\n                              oy - info.metrics.ymax,\n                              ox + info.metrics.xmax,\n                              oy - info.metrics.ymin)\n        else:\n            info.font.draw_glyph_to_bitmap(\n                self.image, ox, oy - info.metrics.iceberg, info.glyph,\n                antialiased=rcParams['text.antialiased'])\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        if self.mode == 'bbox':\n            self._update_bbox(x1, y1, x2, y2)\n        else:\n            height = max(int(y2 - y1) - 1, 0)\n            if height == 0:\n                center = (y2 + y1) / 2.0\n                y = int(center - (height + 1) / 2.0)\n            else:\n                y = int(y1)\n            self.image.draw_rect_filled(int(x1), y, np.ceil(x2), y + height)\n\n    def get_results(self, box):\n        self.mode = 'bbox'\n        orig_height = box.height\n        orig_depth  = box.depth\n        _mathtext.ship(0, 0, box)\n        bbox = self.bbox\n        bbox = [bbox[0] - 1, bbox[1] - 1, bbox[2] + 1, bbox[3] + 1]\n        self.mode = 'render'\n        self.set_canvas_size(\n            bbox[2] - bbox[0],\n            (bbox[3] - bbox[1]) - orig_depth,\n            (bbox[3] - bbox[1]) - orig_height)\n        _mathtext.ship(-bbox[0], -bbox[1], box)\n        result = (self.ox,\n                  self.oy,\n                  self.width,\n                  self.height + self.depth,\n                  self.depth,\n                  self.image)\n        self.image = None\n        return result\n\n    def get_hinting_type(self):\n        from matplotlib.backends import backend_agg\n        return backend_agg.get_hinting_flag()\n\n\nclass MathtextBackendPath(MathtextBackend):\n    \"\"\"\n    Store information to write a mathtext rendering to the text path\n    machinery.\n    \"\"\"\n\n    _Result = namedtuple(\"_Result\", \"width height depth glyphs rects\")\n\n    def __init__(self):\n        super().__init__()\n        self.glyphs = []\n        self.rects = []\n\n    def render_glyph(self, ox, oy, info):\n        oy = self.height - oy + info.offset\n        self.glyphs.append((info.font, info.fontsize, info.num, ox, oy))\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        self.rects.append((x1, self.height - y2, x2 - x1, y2 - y1))\n\n    def get_results(self, box):\n        _mathtext.ship(0, 0, box)\n        return self._Result(self.width,\n                            self.height + self.depth,\n                            self.depth,\n                            self.glyphs,\n                            self.rects)\n\n\nclass MathTextWarning(Warning):\n    pass\n\n\n##############################################################################\n# MAIN\n\n\nclass MathTextParser:\n    _parser = None\n\n    _backend_mapping = {\n        'agg':    MathtextBackendAgg,\n        'path':   MathtextBackendPath,\n        'macosx': MathtextBackendAgg,\n    }\n    _font_type_mapping = {\n        'cm':          _mathtext.BakomaFonts,\n        'dejavuserif': _mathtext.DejaVuSerifFonts,\n        'dejavusans':  _mathtext.DejaVuSansFonts,\n        'stix':        _mathtext.StixFonts,\n        'stixsans':    _mathtext.StixSansFonts,\n        'custom':      _mathtext.UnicodeFonts,\n    }\n\n    def __init__(self, output):\n        \"\"\"Create a MathTextParser for the given backend *output*.\"\"\"\n        self._output = output.lower()\n\n    def parse(self, s, dpi=72, prop=None):\n        \"\"\"\n        Parse the given math expression *s* at the given *dpi*.  If *prop* is\n        provided, it is a `.FontProperties` object specifying the \"default\"\n        font to use in the math expression, used for all non-math text.\n\n        The results are cached, so multiple calls to `parse`\n        with the same expression should be fast.\n        \"\"\"\n        # lru_cache can't decorate parse() directly because prop\n        # is mutable; key the cache using an internal copy (see\n        # text._get_text_metrics_with_cache for a similar case).\n        prop = prop.copy() if prop is not None else None\n        return self._parse_cached(s, dpi, prop)\n\n    @functools.lru_cache(50)\n    def _parse_cached(self, s, dpi, prop):\n        if prop is None:\n            prop = FontProperties()", "extras": {"command": "sed -n '1,240p' /workspace/matplotlib/lib/matplotlib/mathtext.py", "metadata": {"exit_code": 0, "pid": -1, "username": "root", "hostname": "5a92c6348ff8", "working_dir": "/workspace", "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python", "prefix": "", "suffix": "\n[The command completed with exit code 0.]"}, "hidden": false}, "success": true}