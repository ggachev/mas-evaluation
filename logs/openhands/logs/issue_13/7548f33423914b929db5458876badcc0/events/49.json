{"id": 49, "timestamp": "2025-12-13T15:45:01.291771", "source": "agent", "message": "I read the file /workspace/matplotlib/lib/matplotlib/cbook/__init__.py.", "cause": 48, "observation": "read", "tool_call_metadata": {"function_name": "str_replace_editor", "tool_call_id": "call_tG0XwT5eA7BBTm3chA5TIoi0", "model_response": {"id": "chatcmpl-CmM5hOS9hZ3tFREQhA5nN1TFTgh46", "created": 1765640697, "model": "gpt-5-mini-2025-08-07", "object": "chat.completion", "system_fingerprint": null, "choices": [{"finish_reason": "tool_calls", "index": 0, "message": {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"command\":\"view\",\"path\":\"/workspace/matplotlib/lib/matplotlib/cbook/__init__.py\",\"view_range\":[1,240],\"security_risk\":\"LOW\"}", "name": "str_replace_editor"}, "id": "call_tG0XwT5eA7BBTm3chA5TIoi0", "type": "function"}], "function_call": null, "annotations": []}, "provider_specific_fields": {}}], "usage": {"completion_tokens": 183, "prompt_tokens": 29324, "total_tokens": 29507, "completion_tokens_details": {"accepted_prediction_tokens": 0, "audio_tokens": 0, "reasoning_tokens": 128, "rejected_prediction_tokens": 0, "text_tokens": null}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 29056, "text_tokens": null, "image_tokens": null}}, "service_tier": "default"}, "total_calls_in_response": 1}, "content": "Here's the result of running `cat -n` on /workspace/matplotlib/lib/matplotlib/cbook/__init__.py:\n     1\t\"\"\"\n     2\tA collection of utility functions and classes.  Originally, many\n     3\t(but not all) were from the Python Cookbook -- hence the name cbook.\n     4\t\n     5\tThis module is safe to import from anywhere within Matplotlib;\n     6\tit imports Matplotlib only at runtime.\n     7\t\"\"\"\n     8\t\n     9\timport collections\n    10\timport collections.abc\n    11\timport contextlib\n    12\timport functools\n    13\timport gzip\n    14\timport itertools\n    15\timport math\n    16\timport operator\n    17\timport os\n    18\tfrom pathlib import Path\n    19\timport shlex\n    20\timport subprocess\n    21\timport sys\n    22\timport time\n    23\timport traceback\n    24\timport types\n    25\timport warnings\n    26\timport weakref\n    27\t\n    28\timport numpy as np\n    29\t\n    30\timport matplotlib\n    31\tfrom matplotlib import _api, _c_internal_utils\n    32\t\n    33\t\n    34\tdef _get_running_interactive_framework():\n    35\t    \"\"\"\n    36\t    Return the interactive framework whose event loop is currently running, if\n    37\t    any, or \"headless\" if no event loop can be started, or None.\n    38\t\n    39\t    Returns\n    40\t    -------\n    41\t    Optional[str]\n    42\t        One of the following values: \"qt\", \"gtk3\", \"gtk4\", \"wx\", \"tk\",\n    43\t        \"macosx\", \"headless\", ``None``.\n    44\t    \"\"\"\n    45\t    # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as\n    46\t    # entries can also have been explicitly set to None.\n    47\t    QtWidgets = (\n    48\t        sys.modules.get(\"PyQt6.QtWidgets\")\n    49\t        or sys.modules.get(\"PySide6.QtWidgets\")\n    50\t        or sys.modules.get(\"PyQt5.QtWidgets\")\n    51\t        or sys.modules.get(\"PySide2.QtWidgets\")\n    52\t    )\n    53\t    if QtWidgets and QtWidgets.QApplication.instance():\n    54\t        return \"qt\"\n    55\t    Gtk = sys.modules.get(\"gi.repository.Gtk\")\n    56\t    if Gtk:\n    57\t        if Gtk.MAJOR_VERSION == 4:\n    58\t            from gi.repository import GLib\n    59\t            if GLib.main_depth():\n    60\t                return \"gtk4\"\n    61\t        if Gtk.MAJOR_VERSION == 3 and Gtk.main_level():\n    62\t            return \"gtk3\"\n    63\t    wx = sys.modules.get(\"wx\")\n    64\t    if wx and wx.GetApp():\n    65\t        return \"wx\"\n    66\t    tkinter = sys.modules.get(\"tkinter\")\n    67\t    if tkinter:\n    68\t        codes = {tkinter.mainloop.__code__, tkinter.Misc.mainloop.__code__}\n    69\t        for frame in sys._current_frames().values():\n    70\t            while frame:\n    71\t                if frame.f_code in codes:\n    72\t                    return \"tk\"\n    73\t                frame = frame.f_back\n    74\t    macosx = sys.modules.get(\"matplotlib.backends._macosx\")\n    75\t    if macosx and macosx.event_loop_is_running():\n    76\t        return \"macosx\"\n    77\t    if not _c_internal_utils.display_is_valid():\n    78\t        return \"headless\"\n    79\t    return None\n    80\t\n    81\t\n    82\tdef _exception_printer(exc):\n    83\t    if _get_running_interactive_framework() in [\"headless\", None]:\n    84\t        raise exc\n    85\t    else:\n    86\t        traceback.print_exc()\n    87\t\n    88\t\n    89\tclass _StrongRef:\n    90\t    \"\"\"\n    91\t    Wrapper similar to a weakref, but keeping a strong reference to the object.\n    92\t    \"\"\"\n    93\t\n    94\t    def __init__(self, obj):\n    95\t        self._obj = obj\n    96\t\n    97\t    def __call__(self):\n    98\t        return self._obj\n    99\t\n   100\t    def __eq__(self, other):\n   101\t        return isinstance(other, _StrongRef) and self._obj == other._obj\n   102\t\n   103\t    def __hash__(self):\n   104\t        return hash(self._obj)\n   105\t\n   106\t\n   107\tdef _weak_or_strong_ref(func, callback):\n   108\t    \"\"\"\n   109\t    Return a `WeakMethod` wrapping *func* if possible, else a `_StrongRef`.\n   110\t    \"\"\"\n   111\t    try:\n   112\t        return weakref.WeakMethod(func, callback)\n   113\t    except TypeError:\n   114\t        return _StrongRef(func)\n   115\t\n   116\t\n   117\tclass CallbackRegistry:\n   118\t    \"\"\"\n   119\t    Handle registering, processing, blocking, and disconnecting\n   120\t    for a set of signals and callbacks:\n   121\t\n   122\t        >>> def oneat(x):\n   123\t        ...    print('eat', x)\n   124\t        >>> def ondrink(x):\n   125\t        ...    print('drink', x)\n   126\t\n   127\t        >>> from matplotlib.cbook import CallbackRegistry\n   128\t        >>> callbacks = CallbackRegistry()\n   129\t\n   130\t        >>> id_eat = callbacks.connect('eat', oneat)\n   131\t        >>> id_drink = callbacks.connect('drink', ondrink)\n   132\t\n   133\t        >>> callbacks.process('drink', 123)\n   134\t        drink 123\n   135\t        >>> callbacks.process('eat', 456)\n   136\t        eat 456\n   137\t        >>> callbacks.process('be merry', 456)   # nothing will be called\n   138\t\n   139\t        >>> callbacks.disconnect(id_eat)\n   140\t        >>> callbacks.process('eat', 456)        # nothing will be called\n   141\t\n   142\t        >>> with callbacks.blocked(signal='drink'):\n   143\t        ...     callbacks.process('drink', 123)  # nothing will be called\n   144\t        >>> callbacks.process('drink', 123)\n   145\t        drink 123\n   146\t\n   147\t    In practice, one should always disconnect all callbacks when they are\n   148\t    no longer needed to avoid dangling references (and thus memory leaks).\n   149\t    However, real code in Matplotlib rarely does so, and due to its design,\n   150\t    it is rather difficult to place this kind of code.  To get around this,\n   151\t    and prevent this class of memory leaks, we instead store weak references\n   152\t    to bound methods only, so when the destination object needs to die, the\n   153\t    CallbackRegistry won't keep it alive.\n   154\t\n   155\t    Parameters\n   156\t    ----------\n   157\t    exception_handler : callable, optional\n   158\t       If not None, *exception_handler* must be a function that takes an\n   159\t       `Exception` as single parameter.  It gets called with any `Exception`\n   160\t       raised by the callbacks during `CallbackRegistry.process`, and may\n   161\t       either re-raise the exception or handle it in another manner.\n   162\t\n   163\t       The default handler prints the exception (with `traceback.print_exc`) if\n   164\t       an interactive event loop is running; it re-raises the exception if no\n   165\t       interactive event loop is running.\n   166\t\n   167\t    signals : list, optional\n   168\t        If not None, *signals* is a list of signals that this registry handles:\n   169\t        attempting to `process` or to `connect` to a signal not in the list\n   170\t        throws a `ValueError`.  The default, None, does not restrict the\n   171\t        handled signals.\n   172\t    \"\"\"\n   173\t\n   174\t    # We maintain two mappings:\n   175\t    #   callbacks: signal -> {cid -> weakref-to-callback}\n   176\t    #   _func_cid_map: signal -> {weakref-to-callback -> cid}\n   177\t\n   178\t    def __init__(self, exception_handler=_exception_printer, *, signals=None):\n   179\t        self._signals = None if signals is None else list(signals)  # Copy it.\n   180\t        self.exception_handler = exception_handler\n   181\t        self.callbacks = {}\n   182\t        self._cid_gen = itertools.count()\n   183\t        self._func_cid_map = {}\n   184\t        # A hidden variable that marks cids that need to be pickled.\n   185\t        self._pickled_cids = set()\n   186\t\n   187\t    def __getstate__(self):\n   188\t        return {\n   189\t            **vars(self),\n   190\t            # In general, callbacks may not be pickled, so we just drop them,\n   191\t            # unless directed otherwise by self._pickled_cids.\n   192\t            \"callbacks\": {s: {cid: proxy() for cid, proxy in d.items()\n   193\t                              if cid in self._pickled_cids}\n   194\t                          for s, d in self.callbacks.items()},\n   195\t            # It is simpler to reconstruct this from callbacks in __setstate__.\n   196\t            \"_func_cid_map\": None,\n   197\t        }\n   198\t\n   199\t    def __setstate__(self, state):\n   200\t        vars(self).update(state)\n   201\t        self.callbacks = {\n   202\t            s: {cid: _weak_or_strong_ref(func, self._remove_proxy)\n   203\t                for cid, func in d.items()}\n   204\t            for s, d in self.callbacks.items()}\n   205\t        self._func_cid_map = {\n   206\t            s: {proxy: cid for cid, proxy in d.items()}\n   207\t            for s, d in self.callbacks.items()}\n   208\t\n   209\t    def connect(self, signal, func):\n   210\t        \"\"\"Register *func* to be called when signal *signal* is generated.\"\"\"\n   211\t        if signal == \"units finalize\":\n   212\t            _api.warn_deprecated(\n   213\t                \"3.5\", name=signal, obj_type=\"signal\", alternative=\"units\")\n   214\t        if self._signals is not None:\n   215\t            _api.check_in_list(self._signals, signal=signal)\n   216\t        self._func_cid_map.setdefault(signal, {})\n   217\t        proxy = _weak_or_strong_ref(func, self._remove_proxy)\n   218\t        if proxy in self._func_cid_map[signal]:\n   219\t            return self._func_cid_map[signal][proxy]\n   220\t        cid = next(self._cid_gen)\n   221\t        self._func_cid_map[signal][proxy] = cid\n   222\t        self.callbacks.setdefault(signal, {})\n   223\t        self.callbacks[signal][cid] = proxy\n   224\t        return cid\n   225\t\n   226\t    def _connect_picklable(self, signal, func):\n   227\t        \"\"\"\n   228\t        Like `.connect`, but the callback is kept when pickling/unpickling.\n   229\t\n   230\t        Currently internal-use only.\n   231\t        \"\"\"\n   232\t        cid = self.connect(signal, func)\n   233\t        self._pickled_cids.add(cid)\n   234\t        return cid\n   235\t\n   236\t    # Keep a reference to sys.is_finalizing, as sys may have been cleared out\n   237\t    # at that point.\n   238\t    def _remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing):\n   239\t        if _is_finalizing():\n   240\t            # Weakrefs can't be properly torn down at that point anymore.\n", "extras": {"path": "/workspace/matplotlib/lib/matplotlib/cbook/__init__.py", "impl_source": "oh_aci"}}