{"id": 37, "timestamp": "2025-12-13T08:21:41.939260", "source": "agent", "message": "I read the file /workspace/flask/src/flask/blueprints.py.", "cause": 36, "observation": "read", "tool_call_metadata": {"function_name": "str_replace_editor", "tool_call_id": "call_A2i3ORq5WYb260oxVewoBCff", "model_response": {"id": "chatcmpl-CmFAia6wkBk4og3PrSmWIdxlOIDpo", "created": 1765614100, "model": "gpt-5-mini-2025-08-07", "object": "chat.completion", "system_fingerprint": null, "choices": [{"finish_reason": "tool_calls", "index": 0, "message": {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"command\":\"view\",\"path\":\"/workspace/flask/src/flask/blueprints.py\",\"view_range\":[220,500],\"security_risk\":\"LOW\"}", "name": "str_replace_editor"}, "id": "call_A2i3ORq5WYb260oxVewoBCff", "type": "function"}], "function_call": null, "annotations": []}, "provider_specific_fields": {}}], "usage": {"completion_tokens": 45, "prompt_tokens": 21119, "total_tokens": 21164, "completion_tokens_details": {"accepted_prediction_tokens": 0, "audio_tokens": 0, "reasoning_tokens": 0, "rejected_prediction_tokens": 0, "text_tokens": null}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 18432, "text_tokens": null, "image_tokens": null}}, "service_tier": "default"}, "total_calls_in_response": 1}, "content": "Here's the result of running `cat -n` on /workspace/flask/src/flask/blueprints.py:\n   220\t        \"\"\"Registers a function that is called when the blueprint is\n   221\t        registered on the application.  This function is called with the\n   222\t        state as argument as returned by the :meth:`make_setup_state`\n   223\t        method.\n   224\t        \"\"\"\n   225\t        self.deferred_functions.append(func)\n   226\t\n   227\t    @setupmethod\n   228\t    def record_once(self, func: t.Callable) -> None:\n   229\t        \"\"\"Works like :meth:`record` but wraps the function in another\n   230\t        function that will ensure the function is only called once.  If the\n   231\t        blueprint is registered a second time on the application, the\n   232\t        function passed is not called.\n   233\t        \"\"\"\n   234\t\n   235\t        def wrapper(state: BlueprintSetupState) -> None:\n   236\t            if state.first_registration:\n   237\t                func(state)\n   238\t\n   239\t        self.record(update_wrapper(wrapper, func))\n   240\t\n   241\t    def make_setup_state(\n   242\t        self, app: \"Flask\", options: dict, first_registration: bool = False\n   243\t    ) -> BlueprintSetupState:\n   244\t        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n   245\t        object that is later passed to the register callback functions.\n   246\t        Subclasses can override this to return a subclass of the setup state.\n   247\t        \"\"\"\n   248\t        return BlueprintSetupState(self, app, options, first_registration)\n   249\t\n   250\t    @setupmethod\n   251\t    def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n   252\t        \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n   253\t        arguments passed to this method will override the defaults set\n   254\t        on the blueprint.\n   255\t\n   256\t        .. versionchanged:: 2.0.1\n   257\t            The ``name`` option can be used to change the (pre-dotted)\n   258\t            name the blueprint is registered with. This allows the same\n   259\t            blueprint to be registered multiple times with unique names\n   260\t            for ``url_for``.\n   261\t\n   262\t        .. versionadded:: 2.0\n   263\t        \"\"\"\n   264\t        if blueprint is self:\n   265\t            raise ValueError(\"Cannot register a blueprint on itself\")\n   266\t        self._blueprints.append((blueprint, options))\n   267\t\n   268\t    def register(self, app: \"Flask\", options: dict) -> None:\n   269\t        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n   270\t        views and callbacks registered on the blueprint with the\n   271\t        application. Creates a :class:`.BlueprintSetupState` and calls\n   272\t        each :meth:`record` callback with it.\n   273\t\n   274\t        :param app: The application this blueprint is being registered\n   275\t            with.\n   276\t        :param options: Keyword arguments forwarded from\n   277\t            :meth:`~Flask.register_blueprint`.\n   278\t\n   279\t        .. versionchanged:: 2.3\n   280\t            Nested blueprints now correctly apply subdomains.\n   281\t\n   282\t        .. versionchanged:: 2.1\n   283\t            Registering the same blueprint with the same name multiple\n   284\t            times is an error.\n   285\t\n   286\t        .. versionchanged:: 2.0.1\n   287\t            Nested blueprints are registered with their dotted name.\n   288\t            This allows different blueprints with the same name to be\n   289\t            nested at different locations.\n   290\t\n   291\t        .. versionchanged:: 2.0.1\n   292\t            The ``name`` option can be used to change the (pre-dotted)\n   293\t            name the blueprint is registered with. This allows the same\n   294\t            blueprint to be registered multiple times with unique names\n   295\t            for ``url_for``.\n   296\t        \"\"\"\n   297\t        name_prefix = options.get(\"name_prefix\", \"\")\n   298\t        self_name = options.get(\"name\", self.name)\n   299\t        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n   300\t\n   301\t        if name in app.blueprints:\n   302\t            bp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\n   303\t            existing_at = f\" '{name}'\" if self_name != name else \"\"\n   304\t\n   305\t            raise ValueError(\n   306\t                f\"The name '{self_name}' is already registered for\"\n   307\t                f\" {bp_desc} blueprint{existing_at}. Use 'name=' to\"\n   308\t                f\" provide a unique name.\"\n   309\t            )\n   310\t\n   311\t        first_bp_registration = not any(bp is self for bp in app.blueprints.values())\n   312\t        first_name_registration = name not in app.blueprints\n   313\t\n   314\t        app.blueprints[name] = self\n   315\t        self._got_registered_once = True\n   316\t        state = self.make_setup_state(app, options, first_bp_registration)\n   317\t\n   318\t        if self.has_static_folder:\n   319\t            state.add_url_rule(\n   320\t                f\"{self.static_url_path}/<path:filename>\",\n   321\t                view_func=self.send_static_file,\n   322\t                endpoint=\"static\",\n   323\t            )\n   324\t\n   325\t        # Merge blueprint data into parent.\n   326\t        if first_bp_registration or first_name_registration:\n   327\t\n   328\t            def extend(bp_dict, parent_dict):\n   329\t                for key, values in bp_dict.items():\n   330\t                    key = name if key is None else f\"{name}.{key}\"\n   331\t                    parent_dict[key].extend(values)\n   332\t\n   333\t            for key, value in self.error_handler_spec.items():\n   334\t                key = name if key is None else f\"{name}.{key}\"\n   335\t                value = defaultdict(\n   336\t                    dict,\n   337\t                    {\n   338\t                        code: {\n   339\t                            exc_class: func for exc_class, func in code_values.items()\n   340\t                        }\n   341\t                        for code, code_values in value.items()\n   342\t                    },\n   343\t                )\n   344\t                app.error_handler_spec[key] = value\n   345\t\n   346\t            for endpoint, func in self.view_functions.items():\n   347\t                app.view_functions[endpoint] = func\n   348\t\n   349\t            extend(self.before_request_funcs, app.before_request_funcs)\n   350\t            extend(self.after_request_funcs, app.after_request_funcs)\n   351\t            extend(\n   352\t                self.teardown_request_funcs,\n   353\t                app.teardown_request_funcs,\n   354\t            )\n   355\t            extend(self.url_default_functions, app.url_default_functions)\n   356\t            extend(self.url_value_preprocessors, app.url_value_preprocessors)\n   357\t            extend(self.template_context_processors, app.template_context_processors)\n   358\t\n   359\t        for deferred in self.deferred_functions:\n   360\t            deferred(state)\n   361\t\n   362\t        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n   363\t\n   364\t        if self.cli.commands:\n   365\t            if cli_resolved_group is None:\n   366\t                app.cli.commands.update(self.cli.commands)\n   367\t            elif cli_resolved_group is _sentinel:\n   368\t                self.cli.name = name\n   369\t                app.cli.add_command(self.cli)\n   370\t            else:\n   371\t                self.cli.name = cli_resolved_group\n   372\t                app.cli.add_command(self.cli)\n   373\t\n   374\t        for blueprint, bp_options in self._blueprints:\n   375\t            bp_options = bp_options.copy()\n   376\t            bp_url_prefix = bp_options.get(\"url_prefix\")\n   377\t            bp_subdomain = bp_options.get(\"subdomain\")\n   378\t\n   379\t            if bp_subdomain is None:\n   380\t                bp_subdomain = blueprint.subdomain\n   381\t\n   382\t            if state.subdomain is not None and bp_subdomain is not None:\n   383\t                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n   384\t            elif bp_subdomain is not None:\n   385\t                bp_options[\"subdomain\"] = bp_subdomain\n   386\t            elif state.subdomain is not None:\n   387\t                bp_options[\"subdomain\"] = state.subdomain\n   388\t\n   389\t            if bp_url_prefix is None:\n   390\t                bp_url_prefix = blueprint.url_prefix\n   391\t\n   392\t            if state.url_prefix is not None and bp_url_prefix is not None:\n   393\t                bp_options[\"url_prefix\"] = (\n   394\t                    state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n   395\t                )\n   396\t            elif bp_url_prefix is not None:\n   397\t                bp_options[\"url_prefix\"] = bp_url_prefix\n   398\t            elif state.url_prefix is not None:\n   399\t                bp_options[\"url_prefix\"] = state.url_prefix\n   400\t\n   401\t            bp_options[\"name_prefix\"] = name\n   402\t            blueprint.register(app, bp_options)\n   403\t\n   404\t    @setupmethod\n   405\t    def add_url_rule(\n   406\t        self,\n   407\t        rule: str,\n   408\t        endpoint: t.Optional[str] = None,\n   409\t        view_func: t.Optional[ft.RouteCallable] = None,\n   410\t        provide_automatic_options: t.Optional[bool] = None,\n   411\t        **options: t.Any,\n   412\t    ) -> None:\n   413\t        \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n   414\t        full documentation.\n   415\t\n   416\t        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\n   417\t        used with :func:`url_for`, is prefixed with the blueprint's name.\n   418\t        \"\"\"\n   419\t        if endpoint and \".\" in endpoint:\n   420\t            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n   421\t\n   422\t        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n   423\t            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n   424\t\n   425\t        self.record(\n   426\t            lambda s: s.add_url_rule(\n   427\t                rule,\n   428\t                endpoint,\n   429\t                view_func,\n   430\t                provide_automatic_options=provide_automatic_options,\n   431\t                **options,\n   432\t            )\n   433\t        )\n   434\t\n   435\t    @setupmethod\n   436\t    def app_template_filter(\n   437\t        self, name: t.Optional[str] = None\n   438\t    ) -> t.Callable[[T_template_filter], T_template_filter]:\n   439\t        \"\"\"Register a template filter, available in any template rendered by the\n   440\t        application. Equivalent to :meth:`.Flask.template_filter`.\n   441\t\n   442\t        :param name: the optional name of the filter, otherwise the\n   443\t                     function name will be used.\n   444\t        \"\"\"\n   445\t\n   446\t        def decorator(f: T_template_filter) -> T_template_filter:\n   447\t            self.add_app_template_filter(f, name=name)\n   448\t            return f\n   449\t\n   450\t        return decorator\n   451\t\n   452\t    @setupmethod\n   453\t    def add_app_template_filter(\n   454\t        self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None\n   455\t    ) -> None:\n   456\t        \"\"\"Register a template filter, available in any template rendered by the\n   457\t        application. Works like the :meth:`app_template_filter` decorator. Equivalent to\n   458\t        :meth:`.Flask.add_template_filter`.\n   459\t\n   460\t        :param name: the optional name of the filter, otherwise the\n   461\t                     function name will be used.\n   462\t        \"\"\"\n   463\t\n   464\t        def register_template(state: BlueprintSetupState) -> None:\n   465\t            state.app.jinja_env.filters[name or f.__name__] = f\n   466\t\n   467\t        self.record_once(register_template)\n   468\t\n   469\t    @setupmethod\n   470\t    def app_template_test(\n   471\t        self, name: t.Optional[str] = None\n   472\t    ) -> t.Callable[[T_template_test], T_template_test]:\n   473\t        \"\"\"Register a template test, available in any template rendered by the\n   474\t        application. Equivalent to :meth:`.Flask.template_test`.\n   475\t\n   476\t        .. versionadded:: 0.10\n   477\t\n   478\t        :param name: the optional name of the test, otherwise the\n   479\t                     function name will be used.\n   480\t        \"\"\"\n   481\t\n   482\t        def decorator(f: T_template_test) -> T_template_test:\n   483\t            self.add_app_template_test(f, name=name)\n   484\t            return f\n   485\t\n   486\t        return decorator\n   487\t\n   488\t    @setupmethod\n   489\t    def add_app_template_test(\n   490\t        self, f: ft.TemplateTestCallable, name: t.Optional[str] = None\n   491\t    ) -> None:\n   492\t        \"\"\"Register a template test, available in any template rendered by the\n   493\t        application. Works like the :meth:`app_template_test` decorator. Equivalent to\n   494\t        :meth:`.Flask.add_template_test`.\n   495\t\n   496\t        .. versionadded:: 0.10\n   497\t\n   498\t        :param name: the optional name of the test, otherwise the\n   499\t                     function name will be used.\n   500\t        \"\"\"\n", "extras": {"path": "/workspace/flask/src/flask/blueprints.py", "impl_source": "oh_aci"}}