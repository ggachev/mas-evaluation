{"id": 37, "timestamp": "2025-12-13T15:18:48.295769", "source": "agent", "message": "Command `sed -n '1,240p' scikit-learn/sklearn/linear_model/tests/test_ridge.py` executed with exit code 0.", "cause": 36, "observation": "run", "tool_call_metadata": {"function_name": "execute_bash", "tool_call_id": "call_fWRo6UxCXsp5uNCzx2uLNRtu", "model_response": {"id": "chatcmpl-CmLgMCyNTQMa2iLspxGEuulDnmXpc", "created": 1765639126, "model": "gpt-5-mini-2025-08-07", "object": "chat.completion", "system_fingerprint": null, "choices": [{"finish_reason": "tool_calls", "index": 0, "message": {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"command\":\"sed -n '1,240p' scikit-learn/sklearn/linear_model/tests/test_ridge.py\",\"timeout\":120000,\"security_risk\":\"LOW\"}", "name": "execute_bash"}, "id": "call_fWRo6UxCXsp5uNCzx2uLNRtu", "type": "function"}], "function_call": null, "annotations": []}, "provider_specific_fields": {}}], "usage": {"completion_tokens": 51, "prompt_tokens": 29754, "total_tokens": 29805, "completion_tokens_details": {"accepted_prediction_tokens": 0, "audio_tokens": 0, "reasoning_tokens": 0, "rejected_prediction_tokens": 0, "text_tokens": null}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 28288, "text_tokens": null, "image_tokens": null}}, "service_tier": "default"}, "total_calls_in_response": 1}, "content": "import numpy as np\nimport scipy.sparse as sp\nfrom scipy import linalg\nfrom itertools import product\n\nfrom sklearn.utils.testing import assert_true\nfrom sklearn.utils.testing import assert_almost_equal\nfrom sklearn.utils.testing import assert_array_almost_equal\nfrom sklearn.utils.testing import assert_equal\nfrom sklearn.utils.testing import assert_array_equal\nfrom sklearn.utils.testing import assert_greater\nfrom sklearn.utils.testing import assert_raises\nfrom sklearn.utils.testing import assert_raise_message\nfrom sklearn.utils.testing import ignore_warnings\nfrom sklearn.utils.testing import assert_warns\n\nfrom sklearn import datasets\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import make_scorer\nfrom sklearn.metrics import get_scorer\n\nfrom sklearn.linear_model.base import LinearRegression\nfrom sklearn.linear_model.ridge import ridge_regression\nfrom sklearn.linear_model.ridge import Ridge\nfrom sklearn.linear_model.ridge import _RidgeGCV\nfrom sklearn.linear_model.ridge import RidgeCV\nfrom sklearn.linear_model.ridge import RidgeClassifier\nfrom sklearn.linear_model.ridge import RidgeClassifierCV\nfrom sklearn.linear_model.ridge import _solve_cholesky\nfrom sklearn.linear_model.ridge import _solve_cholesky_kernel\nfrom sklearn.datasets import make_regression\n\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.model_selection import KFold\n\nfrom sklearn.utils import check_random_state\nfrom sklearn.datasets import make_multilabel_classification\n\ndiabetes = datasets.load_diabetes()\nX_diabetes, y_diabetes = diabetes.data, diabetes.target\nind = np.arange(X_diabetes.shape[0])\nrng = np.random.RandomState(0)\nrng.shuffle(ind)\nind = ind[:200]\nX_diabetes, y_diabetes = X_diabetes[ind], y_diabetes[ind]\n\niris = datasets.load_iris()\n\nX_iris = sp.csr_matrix(iris.data)\ny_iris = iris.target\n\nDENSE_FILTER = lambda X: X\nSPARSE_FILTER = lambda X: sp.csr_matrix(X)\n\n\ndef test_ridge():\n    # Ridge regression convergence test using score\n    # TODO: for this test to be robust, we should use a dataset instead\n    # of np.random.\n    rng = np.random.RandomState(0)\n    alpha = 1.0\n\n    for solver in (\"svd\", \"sparse_cg\", \"cholesky\", \"lsqr\", \"sag\"):\n        # With more samples than features\n        n_samples, n_features = 6, 5\n        y = rng.randn(n_samples)\n        X = rng.randn(n_samples, n_features)\n\n        ridge = Ridge(alpha=alpha, solver=solver)\n        ridge.fit(X, y)\n        assert_equal(ridge.coef_.shape, (X.shape[1], ))\n        assert_greater(ridge.score(X, y), 0.47)\n\n        if solver in (\"cholesky\", \"sag\"):\n            # Currently the only solvers to support sample_weight.\n            ridge.fit(X, y, sample_weight=np.ones(n_samples))\n            assert_greater(ridge.score(X, y), 0.47)\n\n        # With more features than samples\n        n_samples, n_features = 5, 10\n        y = rng.randn(n_samples)\n        X = rng.randn(n_samples, n_features)\n        ridge = Ridge(alpha=alpha, solver=solver)\n        ridge.fit(X, y)\n        assert_greater(ridge.score(X, y), .9)\n\n        if solver in (\"cholesky\", \"sag\"):\n            # Currently the only solvers to support sample_weight.\n            ridge.fit(X, y, sample_weight=np.ones(n_samples))\n            assert_greater(ridge.score(X, y), 0.9)\n\n\ndef test_primal_dual_relationship():\n    y = y_diabetes.reshape(-1, 1)\n    coef = _solve_cholesky(X_diabetes, y, alpha=[1e-2])\n    K = np.dot(X_diabetes, X_diabetes.T)\n    dual_coef = _solve_cholesky_kernel(K, y, alpha=[1e-2])\n    coef2 = np.dot(X_diabetes.T, dual_coef).T\n    assert_array_almost_equal(coef, coef2)\n\n\ndef test_ridge_singular():\n    # test on a singular matrix\n    rng = np.random.RandomState(0)\n    n_samples, n_features = 6, 6\n    y = rng.randn(n_samples // 2)\n    y = np.concatenate((y, y))\n    X = rng.randn(n_samples // 2, n_features)\n    X = np.concatenate((X, X), axis=0)\n\n    ridge = Ridge(alpha=0)\n    ridge.fit(X, y)\n    assert_greater(ridge.score(X, y), 0.9)\n\n\ndef test_ridge_regression_sample_weights():\n    rng = np.random.RandomState(0)\n\n    for solver in (\"cholesky\", ):\n        for n_samples, n_features in ((6, 5), (5, 10)):\n            for alpha in (1.0, 1e-2):\n                y = rng.randn(n_samples)\n                X = rng.randn(n_samples, n_features)\n                sample_weight = 1.0 + rng.rand(n_samples)\n\n                coefs = ridge_regression(X, y,\n                                         alpha=alpha,\n                                         sample_weight=sample_weight,\n                                         solver=solver)\n\n                # Sample weight can be implemented via a simple rescaling\n                # for the square loss.\n                coefs2 = ridge_regression(\n                    X * np.sqrt(sample_weight)[:, np.newaxis],\n                    y * np.sqrt(sample_weight),\n                    alpha=alpha, solver=solver)\n                assert_array_almost_equal(coefs, coefs2)\n\n\ndef test_ridge_sample_weights():\n    # TODO: loop over sparse data as well\n\n    rng = np.random.RandomState(0)\n    param_grid = product((1.0, 1e-2), (True, False),\n                         ('svd', 'cholesky', 'lsqr', 'sparse_cg'))\n\n    for n_samples, n_features in ((6, 5), (5, 10)):\n\n        y = rng.randn(n_samples)\n        X = rng.randn(n_samples, n_features)\n        sample_weight = 1.0 + rng.rand(n_samples)\n\n        for (alpha, intercept, solver) in param_grid:\n\n            # Ridge with explicit sample_weight\n            est = Ridge(alpha=alpha, fit_intercept=intercept, solver=solver)\n            est.fit(X, y, sample_weight=sample_weight)\n            coefs = est.coef_\n            inter = est.intercept_\n\n            # Closed form of the weighted regularized least square\n            # theta = (X^T W X + alpha I)^(-1) * X^T W y\n            W = np.diag(sample_weight)\n            if intercept is False:\n                X_aug = X\n                I = np.eye(n_features)\n            else:\n                dummy_column = np.ones(shape=(n_samples, 1))\n                X_aug = np.concatenate((dummy_column, X), axis=1)\n                I = np.eye(n_features + 1)\n                I[0, 0] = 0\n\n            cf_coefs = linalg.solve(X_aug.T.dot(W).dot(X_aug) + alpha * I,\n                                    X_aug.T.dot(W).dot(y))\n\n            if intercept is False:\n                assert_array_almost_equal(coefs, cf_coefs)\n            else:\n                assert_array_almost_equal(coefs, cf_coefs[1:])\n                assert_almost_equal(inter, cf_coefs[0])\n\n\ndef test_ridge_shapes():\n    # Test shape of coef_ and intercept_\n    rng = np.random.RandomState(0)\n    n_samples, n_features = 5, 10\n    X = rng.randn(n_samples, n_features)\n    y = rng.randn(n_samples)\n    Y1 = y[:, np.newaxis]\n    Y = np.c_[y, 1 + y]\n\n    ridge = Ridge()\n\n    ridge.fit(X, y)\n    assert_equal(ridge.coef_.shape, (n_features,))\n    assert_equal(ridge.intercept_.shape, ())\n\n    ridge.fit(X, Y1)\n    assert_equal(ridge.coef_.shape, (1, n_features))\n    assert_equal(ridge.intercept_.shape, (1, ))\n\n    ridge.fit(X, Y)\n    assert_equal(ridge.coef_.shape, (2, n_features))\n    assert_equal(ridge.intercept_.shape, (2, ))\n\n\ndef test_ridge_intercept():\n    # Test intercept with multiple targets GH issue #708\n    rng = np.random.RandomState(0)\n    n_samples, n_features = 5, 10\n    X = rng.randn(n_samples, n_features)\n    y = rng.randn(n_samples)\n    Y = np.c_[y, 1. + y]\n\n    ridge = Ridge()\n\n    ridge.fit(X, y)\n    intercept = ridge.intercept_\n\n    ridge.fit(X, Y)\n    assert_almost_equal(ridge.intercept_[0], intercept)\n    assert_almost_equal(ridge.intercept_[1], intercept + 1.)\n\n\ndef test_toy_ridge_object():\n    # Test BayesianRegression ridge classifier\n    # TODO: test also n_samples > n_features\n    X = np.array([[1], [2]])\n    Y = np.array([1, 2])\n    reg = Ridge(alpha=0.0)\n    reg.fit(X, Y)\n    X_test = [[1], [2], [3], [4]]\n    assert_almost_equal(reg.predict(X_test), [1., 2, 3, 4])\n\n    assert_equal(len(reg.coef_.shape), 1)\n    assert_equal(type(reg.intercept_), np.float64)\n\n    Y = np.vstack((Y, Y)).T\n\n    reg.fit(X, Y)", "extras": {"command": "sed -n '1,240p' scikit-learn/sklearn/linear_model/tests/test_ridge.py", "metadata": {"exit_code": 0, "pid": -1, "username": "root", "hostname": "93599edb77bc", "working_dir": "/workspace", "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python", "prefix": "", "suffix": "\n[The command completed with exit code 0.]"}, "hidden": false}, "success": true}