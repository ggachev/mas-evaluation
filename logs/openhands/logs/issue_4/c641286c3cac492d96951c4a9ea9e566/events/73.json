{"id": 73, "timestamp": "2025-12-13T13:53:09.577213", "source": "agent", "message": "Command `sed -n '1,240p' matplotlib/lib/matplotlib/_api/__init__.py` executed with exit code 0.", "cause": 72, "observation": "run", "tool_call_metadata": {"function_name": "execute_bash", "tool_call_id": "call_TEbeDhUq20rPRrO1Fpv2MOAr", "model_response": {"id": "chatcmpl-CmKLLSrMJCHp4hWMdT2DNL3cAyvLT", "created": 1765633979, "model": "gpt-5-mini-2025-08-07", "object": "chat.completion", "system_fingerprint": null, "choices": [{"finish_reason": "tool_calls", "index": 0, "message": {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"command\":\"sed -n '1,240p' matplotlib/lib/matplotlib/_api/__init__.py\",\"timeout\":120000,\"security_risk\":\"LOW\"}", "name": "execute_bash"}, "id": "call_TEbeDhUq20rPRrO1Fpv2MOAr", "type": "function"}], "function_call": null, "annotations": []}, "provider_specific_fields": {}}], "usage": {"completion_tokens": 758, "prompt_tokens": 42389, "total_tokens": 43147, "completion_tokens_details": {"accepted_prediction_tokens": 0, "audio_tokens": 0, "reasoning_tokens": 704, "rejected_prediction_tokens": 0, "text_tokens": null}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 38528, "text_tokens": null, "image_tokens": null}}, "service_tier": "default"}, "total_calls_in_response": 1}, "content": "\"\"\"\nHelper functions for managing the Matplotlib API.\n\nThis documentation is only relevant for Matplotlib developers, not for users.\n\n.. warning::\n\n    This module and its submodules are for internal use only.  Do not use them\n    in your own code.  We may change the API at any time with no warning.\n\n\"\"\"\n\nimport functools\nimport itertools\nimport re\nimport sys\nimport warnings\n\nfrom .deprecation import (\n    deprecated, warn_deprecated,\n    rename_parameter, delete_parameter, make_keyword_only,\n    deprecate_method_override, deprecate_privatize_attribute,\n    suppress_matplotlib_deprecation_warning,\n    MatplotlibDeprecationWarning)\n\n\nclass classproperty:\n    \"\"\"\n    Like `property`, but also triggers on access via the class, and it is the\n    *class* that's passed as argument.\n\n    Examples\n    --------\n    ::\n\n        class C:\n            @classproperty\n            def foo(cls):\n                return cls.__name__\n\n        assert C.foo == \"C\"\n    \"\"\"\n\n    def __init__(self, fget, fset=None, fdel=None, doc=None):\n        self._fget = fget\n        if fset is not None or fdel is not None:\n            raise ValueError('classproperty only implements fget.')\n        self.fset = fset\n        self.fdel = fdel\n        # docs are ignored for now\n        self._doc = doc\n\n    def __get__(self, instance, owner):\n        return self._fget(owner)\n\n    @property\n    def fget(self):\n        return self._fget\n\n\n# In the following check_foo() functions, the first parameter starts with an\n# underscore because it is intended to be positional-only (e.g., so that\n# `_api.check_isinstance([...], types=foo)` doesn't fail.\n\ndef check_isinstance(_types, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is an instance\n    of one of *_types*; if not, raise an appropriate TypeError.\n\n    As a special case, a ``None`` entry in *_types* is treated as NoneType.\n\n    Examples\n    --------\n    >>> _api.check_isinstance((SomeClass, None), arg=arg)\n    \"\"\"\n    types = _types\n    none_type = type(None)\n    types = ((types,) if isinstance(types, type) else\n             (none_type,) if types is None else\n             tuple(none_type if tp is None else tp for tp in types))\n\n    def type_name(tp):\n        return (\"None\" if tp is none_type\n                else tp.__qualname__ if tp.__module__ == \"builtins\"\n                else f\"{tp.__module__}.{tp.__qualname__}\")\n\n    for k, v in kwargs.items():\n        if not isinstance(v, types):\n            names = [*map(type_name, types)]\n            if \"None\" in names:  # Move it to the end for better wording.\n                names.remove(\"None\")\n                names.append(\"None\")\n            raise TypeError(\n                \"{!r} must be an instance of {}, not a {}\".format(\n                    k,\n                    \", \".join(names[:-1]) + \" or \" + names[-1]\n                    if len(names) > 1 else names[0],\n                    type_name(type(v))))\n\n\ndef check_in_list(_values, *, _print_supported_values=True, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is in *_values*.\n\n    Parameters\n    ----------\n    _values : iterable\n        Sequence of values to check on.\n    _print_supported_values : bool, default: True\n        Whether to print *_values* when raising ValueError.\n    **kwargs : dict\n        *key, value* pairs as keyword arguments to find in *_values*.\n\n    Raises\n    ------\n    ValueError\n        If any *value* in *kwargs* is not found in *_values*.\n\n    Examples\n    --------\n    >>> _api.check_in_list([\"foo\", \"bar\"], arg=arg, other_arg=other_arg)\n    \"\"\"\n    values = _values\n    for key, val in kwargs.items():\n        if val not in values:\n            msg = f\"{val!r} is not a valid value for {key}\"\n            if _print_supported_values:\n                msg += f\"; supported values are {', '.join(map(repr, values))}\"\n            raise ValueError(msg)\n\n\ndef check_shape(_shape, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* has the shape\n    *_shape*, if not, raise an appropriate ValueError.\n\n    *None* in the shape is treated as a \"free\" size that can have any length.\n    e.g. (None, 2) -> (N, 2)\n\n    The values checked must be numpy arrays.\n\n    Examples\n    --------\n    To check for (N, 2) shaped arrays\n\n    >>> _api.check_shape((None, 2), arg=arg, other_arg=other_arg)\n    \"\"\"\n    target_shape = _shape\n    for k, v in kwargs.items():\n        data_shape = v.shape\n\n        if len(target_shape) != len(data_shape) or any(\n                t not in [s, None]\n                for t, s in zip(target_shape, data_shape)\n        ):\n            dim_labels = iter(itertools.chain(\n                'MNLIJKLH',\n                (f\"D{i}\" for i in itertools.count())))\n            text_shape = \", \".join((str(n)\n                                    if n is not None\n                                    else next(dim_labels)\n                                    for n in target_shape))\n\n            raise ValueError(\n                f\"{k!r} must be {len(target_shape)}D \"\n                f\"with shape ({text_shape}). \"\n                f\"Your input has shape {v.shape}.\"\n            )\n\n\ndef check_getitem(_mapping, **kwargs):\n    \"\"\"\n    *kwargs* must consist of a single *key, value* pair.  If *key* is in\n    *_mapping*, return ``_mapping[value]``; else, raise an appropriate\n    ValueError.\n\n    Examples\n    --------\n    >>> _api.check_getitem({\"foo\": \"bar\"}, arg=arg)\n    \"\"\"\n    mapping = _mapping\n    if len(kwargs) != 1:\n        raise ValueError(\"check_getitem takes a single keyword argument\")\n    (k, v), = kwargs.items()\n    try:\n        return mapping[v]\n    except KeyError:\n        raise ValueError(\n            \"{!r} is not a valid value for {}; supported values are {}\"\n            .format(v, k, ', '.join(map(repr, mapping)))) from None\n\n\ndef caching_module_getattr(cls):\n    \"\"\"\n    Helper decorator for implementing module-level ``__getattr__`` as a class.\n\n    This decorator must be used at the module toplevel as follows::\n\n        @caching_module_getattr\n        class __getattr__:  # The class *must* be named ``__getattr__``.\n            @property  # Only properties are taken into account.\n            def name(self): ...\n\n    The ``__getattr__`` class will be replaced by a ``__getattr__``\n    function such that trying to access ``name`` on the module will\n    resolve the corresponding property (which may be decorated e.g. with\n    ``_api.deprecated`` for deprecating module globals).  The properties are\n    all implicitly cached.  Moreover, a suitable AttributeError is generated\n    and raised if no property with the given name exists.\n    \"\"\"\n\n    assert cls.__name__ == \"__getattr__\"\n    # Don't accidentally export cls dunders.\n    props = {name: prop for name, prop in vars(cls).items()\n             if isinstance(prop, property)}\n    instance = cls()\n\n    @functools.lru_cache(None)\n    def __getattr__(name):\n        if name in props:\n            return props[name].__get__(instance)\n        raise AttributeError(\n            f\"module {cls.__module__!r} has no attribute {name!r}\")\n\n    return __getattr__\n\n\ndef define_aliases(alias_d, cls=None):\n    \"\"\"\n    Class decorator for defining property aliases.\n\n    Use as ::\n\n        @_api.define_aliases({\"property\": [\"alias\", ...], ...})\n        class C: ...\n\n    For each property, if the corresponding ``get_property`` is defined in the\n    class so far, an alias named ``get_alias`` will be defined; the same will\n    be done for setters.  If neither the getter nor the setter exists, an\n    exception will be raised.", "extras": {"command": "sed -n '1,240p' matplotlib/lib/matplotlib/_api/__init__.py", "metadata": {"exit_code": 0, "pid": -1, "username": "root", "hostname": "883d42764748", "working_dir": "/workspace", "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python", "prefix": "", "suffix": "\n[The command completed with exit code 0.]"}, "hidden": false}, "success": true}