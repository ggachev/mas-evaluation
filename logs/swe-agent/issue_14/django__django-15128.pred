{"model_name_or_path": "default_gpt5__gpt-5-mini-2025-08-07__t-1.00__p-None__c-2.00___swe_bench_verified_test", "instance_id": "django__django-15128", "model_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex aaf35ee37c..d252e74df5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -845,37 +845,115 @@ class Query(BaseExpression):\n         Change the aliases in change_map (which maps old-alias -> new-alias),\n         relabelling any references to them in select columns and the where\n         clause.\n+\n+        The incoming change_map may contain mappings where keys and values\n+        intersect (e.g. A->B, B->C). To avoid double-renaming issues, apply\n+        the renames in a sequence of steps that never contain overlapping\n+        sources and targets. Cycles are broken using temporary aliases.\n         \"\"\"\n-        assert set(change_map).isdisjoint(change_map.values())\n+        # Filter the requested changes to aliases that actually exist and\n+        # which are real changes.\n+        orig_change_map = {k: v for k, v in change_map.items() if k in self.alias_map and k != v}\n \n-        # 1. Update references in \"select\" (normal columns plus aliases),\n-        # \"group by\" and \"where\".\n-        self.where.relabel_aliases(change_map)\n-        if isinstance(self.group_by, tuple):\n-            self.group_by = tuple([col.relabeled_clone(change_map) for col in self.group_by])\n-        self.select = tuple([col.relabeled_clone(change_map) for col in self.select])\n-        self.annotations = self.annotations and {\n-            key: col.relabeled_clone(change_map) for key, col in self.annotations.items()\n-        }\n+        # Fast-path: if nothing to do, return early.\n+        if not orig_change_map:\n+            return\n \n-        # 2. Rename the alias in the internal table/alias datastructures.\n-        for old_alias, new_alias in change_map.items():\n-            if old_alias not in self.alias_map:\n+        # Build a working copy of remaining changes.\n+        remaining = dict(orig_change_map)\n+\n+        # Helper to generate a unique temporary alias.\n+        def _mk_temp(existing):\n+            i = 0\n+            temp = \"__change_aliases_temp_%d__\" % i\n+            while temp in existing:\n+                i += 1\n+                temp = \"__change_aliases_temp_%d__\" % i\n+            return temp\n+\n+        steps = []\n+        # existing set of names that must not be collided with when creating temps\n+        existing_aliases = set(self.alias_map) | set(v for v in remaining.values())\n+\n+        while remaining:\n+            # Find safe mappings whose targets are not themselves being renamed.\n+            safe = {k: v for k, v in remaining.items() if v not in remaining}\n+            if safe:\n+                steps.append(safe)\n+                for k in safe:\n+                    del remaining[k]\n                 continue\n-            alias_data = self.alias_map[old_alias].relabeled_clone(change_map)\n-            self.alias_map[new_alias] = alias_data\n-            self.alias_refcount[new_alias] = self.alias_refcount[old_alias]\n-            del self.alias_refcount[old_alias]\n-            del self.alias_map[old_alias]\n-\n-            table_aliases = self.table_map[alias_data.table_name]\n-            for pos, alias in enumerate(table_aliases):\n-                if alias == old_alias:\n-                    table_aliases[pos] = new_alias\n-                    break\n+\n+            # No safe mappings -> we have at least one cycle. Pick a node in a cycle\n+            # and break the cycle using a unique temporary alias.\n+            start = next(iter(remaining))\n+            # follow the chain until we find a repetition to identify the cycle\n+            seq = []\n+            cur = start\n+            while cur not in seq:\n+                seq.append(cur)\n+                cur = remaining[cur]\n+            cycle = seq[seq.index(cur):]\n+\n+            temp = _mk_temp(existing_aliases)\n+            existing_aliases.add(temp)\n+            # To rotate the cycle without conflicts, move the last node to a\n+            # temporary alias, then shift the others up, and finally move the\n+            # temporary alias into the first node's position.\n+            # For cycle [x0, x1, ..., xN], desired mappings are x0->x1, x1->x2, ...,\n+            # xN->x0. The steps are:\n+            #   xN -> temp\n+            #   xN-1 -> xN\n+            #   xN-2 -> xN-1\n+            #   ...\n+            #   x0 -> x1\n+            #   temp -> x0\n+            steps.append({cycle[-1]: temp})\n+            for i in range(len(cycle) - 2, -1, -1):\n+                steps.append({cycle[i]: cycle[i + 1]})\n+            steps.append({temp: cycle[0]})\n+\n+            # Remove the entire cycle from remaining since we've scheduled steps\n+            # to handle it.\n+            for node in cycle:\n+                if node in remaining:\n+                    del remaining[node]\n+\n+        # Now apply the steps sequentially. Each step mapping is guaranteed to\n+        # have disjoint keys and values, so we can safely relabel references and\n+        # move alias_map entries.\n+        for step in steps:\n+            # 1. Update references in \"select\" (normal columns plus aliases),\n+            # \"group by\" and \"where\".\n+            self.where.relabel_aliases(step)\n+            if isinstance(self.group_by, tuple):\n+                self.group_by = tuple([col.relabeled_clone(step) for col in self.group_by])\n+            self.select = tuple([col.relabeled_clone(step) for col in self.select])\n+            self.annotations = self.annotations and {\n+                key: col.relabeled_clone(step) for key, col in self.annotations.items()\n+            }\n+\n+            # 2. Rename the alias in the internal table/alias datastructures.\n+            for old_alias, new_alias in step.items():\n+                if old_alias not in self.alias_map:\n+                    continue\n+                alias_data = self.alias_map[old_alias].relabeled_clone(step)\n+                self.alias_map[new_alias] = alias_data\n+                self.alias_refcount[new_alias] = self.alias_refcount[old_alias]\n+                del self.alias_refcount[old_alias]\n+                del self.alias_map[old_alias]\n+\n+                table_aliases = self.table_map[alias_data.table_name]\n+                for pos, alias in enumerate(table_aliases):\n+                    if alias == old_alias:\n+                        table_aliases[pos] = new_alias\n+                        break\n+\n+        # Finally, update external_aliases to reflect the original requested\n+        # final renames (orig_change_map). This mirrors the old behaviour.\n         self.external_aliases = {\n             # Table is aliased or it's being changed and thus is aliased.\n-            change_map.get(alias, alias): (aliased or alias in change_map)\n+            orig_change_map.get(alias, alias): (aliased or alias in orig_change_map)\n             for alias, aliased in self.external_aliases.items()\n         }\n \n"}